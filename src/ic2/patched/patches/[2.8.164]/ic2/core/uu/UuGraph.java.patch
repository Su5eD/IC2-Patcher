--- a/ic2/core/uu/UuGraph.java
+++ b/ic2/core/uu/UuGraph.java
@@ -26,6 +26,7 @@
    private static final Map<Item, Set<UuGraph.Node>> itemNodes = new IdentityHashMap<>();
    private static final List<UuGraph.InitialValue> initialValues = new ArrayList<>();
    private static volatile Future<?> calculation = null;
+   private static volatile boolean calculationFailed = false;
 
    public static void build(boolean reset) {
       if (calculation != null) {
@@ -63,7 +64,16 @@
          calculation = IC2.getInstance().threadPool.submit(new Runnable() {
             @Override
             public void run() {
-               UuGraph.processRecipes(transformations);
+               // Temporary workaround, if calculation crashes, try rerunning once.
+               // TODO: Replace with proper fix.
+               try {
+                  UuGraph.processRecipes(transformations);
+               } catch (Throwable e) {
+                  IC2.log.error(LogCategory.Uu, e, "Calculations failed%s", calculationFailed? " twice, aborting.": " once, retrying...");
+                  calculation = null;
+                  calculationFailed = true;
+                  build(true);
+               }
             }
          });
       }
@@ -237,14 +247,16 @@
 
                      assert false;
                   } else if (node.value > value / outputSize) {
-                     node.updateValue(nt, outputSize);
+                     // Patch: Call the setValue inside itself instead of in updateValue, decreasing recursion cost. | See #31
+                     // TODO: UU Calculations need a complete rework. This can happen with some other mod as well, but should be way less likely now.
+                     node.setValue(node.updateValue(nt, outputSize));
                   }
                }
             }
          }
       }
 
-      private void updateValue(UuGraph.NodeTransform nt, int outputSize) {
+      private double updateValue(UuGraph.NodeTransform nt, int outputSize) {
          double newValue = nt.transform.transformCost;
 
          for (List<LeanItemStack> inputs : nt.transform.inputs) {
@@ -253,6 +265,7 @@
             for (LeanItemStack input : inputs) {
                double minValue2 = Double.POSITIVE_INFINITY;
 
+               //Note: StackOverflow comes 99% of the time from UuGraph#getAll(LeanItemStack)
                for (UuGraph.Node node : UuGraph.getAll(input)) {
                   if (node.value < minValue2) {
                      minValue2 = node.value;
@@ -268,7 +281,7 @@
             newValue += minValue;
          }
 
-         this.setValue(newValue / outputSize);
+         return newValue / outputSize;
       }
    }
 
